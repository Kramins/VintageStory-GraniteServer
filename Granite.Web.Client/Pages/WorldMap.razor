@page "/world-map"
@page "/{serverId}/world-map"
@attribute [Authorize]
@using Granite.Common.Dto
@using Granite.Common.Messaging.Events.Client
@using Granite.Web.Client.Services
@using Microsoft.JSInterop
@inject WorldMapService MapService
@inject IJSRuntime JSRuntime
@inject ILogger<WorldMap> Logger
@implements IAsyncDisposable

<PageTitle>World Map - Granite Server Manager</PageTitle>

@if (_isLoading)
{
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;">
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        <MudText Align="Align.Center" Class="mt-2">Loading map data...</MudText>
    </div>
}
else if (_error != null)
{
    <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; width: 500px; max-width: 90%;">
        <MudAlert Severity="Severity.Error">@_error</MudAlert>
    </div>
}

@if (_bounds != null)
{
    <div id="map" style="position: fixed; top: 64px; left: 0; right: 0; bottom: 0; width: 100%; height: calc(100vh - 64px);"></div>
}

@code {
    [Parameter]
    public string? ServerId { get; set; }

    private WorldMapBoundsDTO? _bounds;
    private bool _isLoading = true;
    private string? _error;
    private Guid _serverGuid;
    private bool _mapInitialized = false;

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(ServerId) && Guid.TryParse(ServerId, out var guid))
        {
            _serverGuid = guid;
        }
        else
        {
            _error = "No server ID provided. Please select a server first.";
            _isLoading = false;
            return;
        }

        await LoadMapData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_mapInitialized && _bounds != null && _error == null)
        {
            try
            {
                var baseTileUrl = MapService.GetBaseTileUrl(_serverGuid);
                var authToken = await MapService.GetTileServerBearerTokenAsync();

                // Calculate center from bounds
                var centerX = (_bounds.MinChunkX + _bounds.MaxChunkX) / 2.0;
                var centerZ = (_bounds.MinChunkZ + _bounds.MaxChunkZ) / 2.0;

                await JSRuntime.InvokeVoidAsync("mapInterop.initializeMap",
                    "map",
                    baseTileUrl,
                    new[] { centerX, centerZ },
                    authToken
                );

                _mapInitialized = true;
                Logger.LogInformation("Map initialized for server {ServerId} with center ({CenterX}, {CenterZ})",
                    _serverGuid, centerX, centerZ);

                MapService.SubscribeToTileUpdates(_serverGuid, async (evt) =>
                {
                    Logger.LogInformation("Received map tiles update for server {ServerId} with {Count} tiles",
                        _serverGuid, evt.Data.UpdatedTiles.Count);
                    
                    // Batch invalidate all tiles at once for better performance
                    await JSRuntime.InvokeVoidAsync("mapInterop.invalidateTiles", (object)evt.Data.UpdatedTiles);
                });
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing map");
                _error = $"Failed to initialize map: {ex.Message}";
                StateHasChanged();
            }
        }
    }

    private async Task LoadMapData()
    {
        _isLoading = true;
        _error = null;

        try
        {
            _bounds = await MapService.GetWorldBoundsAsync(_serverGuid);

            if (_bounds == null)
            {
                _error = "No map data available for this server.";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading map data");
            _error = $"Failed to load map data: {ex.Message}";
        }
        finally
        {
            _isLoading = false;
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("mapInterop.dispose");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disposing map");
        }
    }
}