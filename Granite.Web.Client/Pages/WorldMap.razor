@page "/world-map"
@page "/{serverId}/world-map"
@attribute [Authorize]
@using Fluxor
@using Fluxor.Blazor.Web.Components
@using Granite.Common.Dto
@using Granite.Common.Messaging.Events.Client
@using Granite.Web.Client.Services
@using Granite.Web.Client.Store.Features.Map
@using Granite.Web.Client.Store.Features.Players
@using Microsoft.JSInterop
@inherits FluxorComponent
@inject WorldMapService MapService
@inject IJSRuntime JSRuntime
@inject ILogger<WorldMap> Logger
@inject IState<MapState> MapState
@inject IDispatcher Dispatcher
@implements IAsyncDisposable

<PageTitle>World Map - Granite Server Manager</PageTitle>

@if (_isLoading)
{
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;">
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        <MudText Align="Align.Center" Class="mt-2">Loading map data...</MudText>
    </div>
}
else if (_error != null)
{
    <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; width: 500px; max-width: 90%;">
        <MudAlert Severity="Severity.Error">@_error</MudAlert>
    </div>
}

@if (_bounds != null)
{
    <div id="map" style="position: fixed; top: 64px; left: 0; right: 0; bottom: 0; width: 100%; height: calc(100vh - 64px);"></div>
}

@code {
    [Parameter]
    public string? ServerId { get; set; }

    private WorldMapBoundsDTO? _bounds;
    private bool _isLoading = true;
    private string? _error;
    private Guid _serverGuid;
    private bool _mapInitialized = false;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        
        if (!string.IsNullOrEmpty(ServerId) && Guid.TryParse(ServerId, out var guid))
        {
            _serverGuid = guid;
            
            // Fetch players for this server to ensure player names are available for markers
            Dispatcher.Dispatch(new FetchPlayersAction(ServerId));
        }
        else
        {
            _error = "No server ID provided. Please select a server first.";
            _isLoading = false;
            return;
        }
        
        await LoadMapData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_mapInitialized && _bounds != null && _error == null)
        {
            try
            {
                var baseTileUrl = MapService.GetBaseTileUrl(_serverGuid);
                var authToken = await MapService.GetTileServerBearerTokenAsync();

                // Calculate center from bounds (convert chunk coords to block coords)
                // Each chunk is 32 blocks, so multiply by 32
                var centerChunkX = (_bounds.MinChunkX + _bounds.MaxChunkX) / 2.0;
                var centerChunkZ = (_bounds.MinChunkZ + _bounds.MaxChunkZ) / 2.0;
                var centerBlockX = centerChunkX * 32;
                var centerBlockZ = centerChunkZ * 32;
                
                // OpenLayers uses [X, -Z] coordinate system
                var mapCenter = new[] { centerBlockX, -centerBlockZ };
                
                Logger.LogInformation("Initializing map at block ({X}, {Z}), map coords [{MapX}, {MapY}]",
                    centerBlockX, centerBlockZ, mapCenter[0], mapCenter[1]);

                await JSRuntime.InvokeVoidAsync("mapInterop.initializeMap",
                    "map",
                    baseTileUrl,
                    mapCenter,
                    authToken
                );

                _mapInitialized = true;
                Logger.LogInformation("Map initialized for server {ServerId} at block ({X}, {Z})",
                    _serverGuid, centerBlockX, centerBlockZ);

                MapService.SubscribeToTileUpdates(_serverGuid, async (evt) =>
                {
                    Logger.LogInformation("Received map tiles update for server {ServerId} with {Count} tiles",
                        _serverGuid, evt.Data.UpdatedTiles.Count);
                    
                    // Batch invalidate all tiles at once for better performance
                    await JSRuntime.InvokeVoidAsync("mapInterop.invalidateTiles", (object)evt.Data.UpdatedTiles);
                });
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing map");
                _error = $"Failed to initialize map: {ex.Message}";
                StateHasChanged();
            }
        }

        // Sync player positions to JavaScript after any render
        if (_mapInitialized && MapState.Value.PlayerPositions.Any())
        {
            try
            {
                Logger.LogInformation("Syncing {Count} player positions to map", MapState.Value.PlayerPositions.Count);
                
                foreach (var position in MapState.Value.PlayerPositions.Values)
                {
                    Logger.LogDebug("Updating marker for {PlayerName} at ({X}, {Z})", 
                        position.PlayerName, position.BlockX, position.BlockZ);
                    
                    await JSRuntime.InvokeVoidAsync(
                        "mapInterop.updatePlayerMarker",
                        position.PlayerUID,
                        position.BlockX,
                        position.BlockZ,
                        position.PlayerName
                    );
                }
                
                Logger.LogInformation("Player positions synced successfully");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error syncing player positions to map");
            }
        }
        else if (_mapInitialized && !MapState.Value.PlayerPositions.Any())
        {
            Logger.LogDebug("Map initialized but no player positions to display");
        }
    }

    private async Task LoadMapData()
    {
        _isLoading = true;
        _error = null;

        try
        {
            _bounds = await MapService.GetWorldBoundsAsync(_serverGuid);

            if (_bounds == null)
            {
                _error = "No map data available for this server.";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading map data");
            _error = $"Failed to load map data: {ex.Message}";
        }
        finally
        {
            _isLoading = false;
        }
    }

    public new async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("mapInterop.dispose");
            await base.DisposeAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disposing map");
        }
    }
}