<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Vintage Story World Map</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@9.2.4/ol.css" />
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #111;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    #debug {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.9);
      color: #0f0;
      padding: 15px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      max-width: 400px;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid #0f0;
    }

    #debug h3 {
      margin: 0 0 10px 0;
      color: #0ff;
    }

    .success {
      color: #0f0;
    }

    .error {
      color: #f00;
    }

    .warning {
      color: #ff0;
    }

    .info {
      color: #08f;
    }
  </style>
</head>

<body>
  <div id="debug">
    <h3>Map Debug Console</h3>
    <div id="log"></div>
  </div>
  <div id="map"></div>
  <script src="https://cdn.jsdelivr.net/npm/ol@9.2.4/dist/ol.js"></script>
  <script>
    const TILE_SIZE = 256;
    const CHUNKS_PER_GROUP = 8;
    const SERVER_ID = 'd3cd8403-ebd3-4cba-a88b-7cc63eb2c0c6';
    const BASE_URL = 'http://localhost:5000';

    const SPAWN_CHUNK_X = 15998;
    const SPAWN_CHUNK_Z = 16000;
    const SPAWN_GROUP_X = Math.floor(SPAWN_CHUNK_X / CHUNKS_PER_GROUP);
    const SPAWN_GROUP_Z = Math.floor(SPAWN_CHUNK_Z / CHUNKS_PER_GROUP);

    const logEl = document.getElementById('log');
    const tileRequests = new Map();

    function log(msg, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const line = `<span class="${type}">[${timestamp}] ${msg}</span><br>`;
      console.log(`[${type.toUpperCase()}] ${msg}`);
      logEl.innerHTML += line;
      logEl.scrollTop = logEl.scrollHeight;
      const lines = logEl.innerHTML.split('<br>');
      if (lines.length > 50) {
        logEl.innerHTML = lines.slice(-50).join('<br>');
      }
    }

    async function testServerConnection() {
      log('Testing server...', 'info');
      const testUrl = `${BASE_URL}/api/worldmap/${SERVER_ID}/tiles/grouped/${SPAWN_GROUP_X}/${SPAWN_GROUP_Z}`;
      log(`URL: ${testUrl}`, 'info');

      try {
        const response = await fetch(testUrl);
        log(`Status: ${response.status}`, response.ok ? 'success' : 'error');

        if (response.ok) {
          const blob = await response.blob();
          log(`âœ“ Blob: ${blob.size} bytes`, 'success');

          const imgUrl = URL.createObjectURL(blob);
          const testImg = new Image();

          await new Promise((resolve, reject) => {
            testImg.onload = () => {
              log(`âœ“ Image: ${testImg.width}x${testImg.height}`, 'success');
              URL.revokeObjectURL(imgUrl);
              resolve();
            };
            testImg.onerror = (e) => {
              log(`âœ— Image load failed`, 'error');
              URL.revokeObjectURL(imgUrl);
              reject(e);
            };
            testImg.src = imgUrl;
          });

          return true;
        }
        return false;
      } catch (err) {
        log(`âœ— Error: ${err.message}`, 'error');
        return false;
      }
    }

    const extent = [-1000000, -1000000, 1000000, 1000000];

    const projection = new ol.proj.Projection({
      code: 'VS-PIXEL',
      units: 'pixels',
      extent: extent
    });

    const tileGrid = new ol.tilegrid.TileGrid({
      origin: [extent[0], extent[3]],  // Top-left corner
      tileSize: TILE_SIZE,
      resolutions: [1]
    });

    const tileSource = new ol.source.TileImage({
      projection: projection,
      tileGrid: tileGrid,
      wrapX: false,
      crossOrigin: 'anonymous',
      tileUrlFunction: function (tileCoord) {
        if (!tileCoord) return null;

        const tileX = tileCoord[1];
        const tileY = tileCoord[2];

        const groupX = tileX + Math.floor(extent[0] / TILE_SIZE);

        // âœ… FIXED: Subtract offset, don't add
        const groupZ = tileY - Math.floor(extent[3] / TILE_SIZE);

        const url = `${BASE_URL}/api/worldmap/${SERVER_ID}/tiles/grouped/${groupX}/${groupZ}`;

        const key = `${groupX},${groupZ}`;
        if (!tileRequests.has(key)) {
          tileRequests.set(key, { requested: Date.now(), url });
          log(`ðŸ“¡ (${groupX}, ${groupZ}) [tile: ${tileX},${tileY}]`, 'info');
        }

        return url;
      },
      tileLoadFunction: function (imageTile, src) {
        const img = imageTile.getImage();
        img.crossOrigin = 'anonymous';

        const match = src.match(/grouped\/(-?\d+)\/(-?\d+)/);
        const coords = match ? `(${match[1]}, ${match[2]})` : '?';

        img.onload = () => log(`âœ“ ${coords}`, 'success');
        img.onerror = () => log(`âœ— ${coords}`, 'error');
        img.src = src;
      }
    });

    const map = new ol.Map({
      target: 'map',
      layers: [new ol.layer.Tile({ source: tileSource })],
      view: new ol.View({
        projection: projection,
        center: [
          SPAWN_GROUP_X * TILE_SIZE,
          -SPAWN_GROUP_Z * TILE_SIZE
        ],
        resolution: 1,
        minResolution: 1,
        maxResolution: 1,
        constrainResolution: true,
        enableRotation: false
      })
    });

    map.on('moveend', () => {
      const center = map.getView().getCenter();
      const gx = Math.round(center[0] / TILE_SIZE);
      const gz = Math.round(-center[1] / TILE_SIZE);
      log(`ðŸ“ Group(${gx}, ${gz})`, 'info');
    });

    map.on('click', (evt) => {
      const [px, py] = evt.coordinate;
      const gx = Math.floor(px / TILE_SIZE);
      const gz = Math.floor(-py / TILE_SIZE);
      log(`ðŸ–±ï¸ (${gx}, ${gz})`, 'info');
    });

    log('=== Init ===', 'info');
    log(`Spawn: Group(${SPAWN_GROUP_X}, ${SPAWN_GROUP_Z})`, 'info');

    testServerConnection().then(ok => {
      if (ok) {
        log('=== Ready ===', 'success');
        setTimeout(() => map.updateSize(), 500);
      }
    });

    window.debugMap = {
      map,
      goToGroup: (x, z) => {
        map.getView().setCenter([x * TILE_SIZE, -z * TILE_SIZE]);
      }
    };
  </script>
</body>

</html>